{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE DeriveAnyClass        #-}
{-# LANGUAGE DeriveGeneric         #-}
{-# LANGUAGE FlexibleContexts      #-}
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE GADTs                 #-}
{-# LANGUAGE InstanceSigs          #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NumericUnderscores    #-}
{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE RankNTypes            #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE StandaloneDeriving    #-}
{-# LANGUAGE TypeApplications      #-}
{-# LANGUAGE TypeFamilies          #-}
{-# LANGUAGE TypeOperators         #-}
module HelloWorld.Contract.ContractModels  where

import Control.Monad (void, forM_)
import Control.Lens hiding (elements)
import Data.Map qualified as M
import Data.Monoid (Last(..))
import Data.Maybe (isNothing, isJust)
import Data.String (fromString)
import Data.Text qualified as T
import GHC.Generics
import Ledger (minAdaTxOut)
import Plutus.V1.Ledger.Ada (toValue)
import Plutus.V1.Ledger.Value (AssetClass)
import Plutus.Contract hiding (currentSlot, throwError)
import Plutus.Contract.Test
import Plutus.Contract.Test.ContractModel
import Plutus.Trace (callEndpoint, throwError)
import Plutus.Trace.Emulator (ContractInstanceTag, EmulatorRuntimeError(..), observableState, waitUntilSlot)
import Plutus.V1.Ledger.Api (CurrencySymbol)

import Test.QuickCheck

import HelloWorld.Contract (InitHelloWorldSchema, IncHelloWorldSchema, ReadHelloWorldSchema, initialize, increment', read'')

type IncHelloWorldSchema' = IncHelloWorldSchema .\/ Endpoint "initialize" CurrencySymbol

increment'' :: Contract () IncHelloWorldSchema' T.Text ()
increment'' = awaitPromise $ endpoint @"initialize" increment'

type ReadHelloWorldSchema' = ReadHelloWorldSchema .\/ Endpoint "initialize" CurrencySymbol
read''' :: Contract (Last Integer) ReadHelloWorldSchema' T.Text ()
read''' = awaitPromise $ endpoint @"initialize" read''

newtype HelloWorldModel = HelloWorldModel { _helloWorldModel :: M.Map Wallet Integer } deriving (Eq, Ord, Show)

makeLenses ''HelloWorldModel

instance ContractModel HelloWorldModel where
  -- Actions that will be generated by QuickCheck and can be performed on the hello world contract
  data Action HelloWorldModel =
      Initialize Wallet Integer
    | Increment Wallet Wallet     -- wallet2 calls increment on contract operated by wallet1
    | Read Wallet Wallet          -- wallet2 reads the current state from contract operated by wallet1
    deriving (Eq, Show)

  data ContractInstanceKey HelloWorldModel w s e p where
    InitializeKey :: Wallet -> Integer -> ContractInstanceKey HelloWorldModel (Last CurrencySymbol) InitHelloWorldSchema T.Text ()
    IncrementKey :: Wallet -> Wallet -> ContractInstanceKey HelloWorldModel () IncHelloWorldSchema' T.Text ()
    ReadKey :: Wallet -> Wallet -> ContractInstanceKey HelloWorldModel (Last Integer) ReadHelloWorldSchema' T.Text ()

  instanceContract :: (SymToken -> AssetClass) -> ContractInstanceKey HelloWorldModel w s e p -> p -> Contract w s e ()
  instanceContract _ (InitializeKey _ _) () = initialize
  instanceContract _ (IncrementKey _ _) () = increment''
  instanceContract _ (ReadKey _ _) () = read'''

  instanceWallet :: ContractInstanceKey HelloWorldModel w s e p -> Wallet
  instanceWallet (InitializeKey w _) = w
  instanceWallet (IncrementKey w _) = w
  instanceWallet (ReadKey w _) = w

  instanceTag :: SchemaConstraints w s e => ContractInstanceKey HelloWorldModel w s e p -> ContractInstanceTag
  instanceTag key = fromString $ "instance tag for: " <> show key

  arbitraryAction :: ModelState HelloWorldModel -> Gen (Action HelloWorldModel)
  arbitraryAction _ = oneof [
                        Initialize <$> genWallet <*> arbitrary
                      , Increment <$> genWallet <*> genWallet
                      , Read <$> genWallet <*> genWallet
                      ]

  initialState :: HelloWorldModel
  initialState = HelloWorldModel M.empty

  initialInstances :: [StartContract HelloWorldModel]
  initialInstances = [ StartContract (InitializeKey w i) () | w <- wallets, i <- [-2, -1..10] ]
                  <> [ StartContract (IncrementKey w1 w2) () | w <- wallets, w2 <- wallets ]
                  <> [ StartContract (ReadKey w1 w2) () | w <- wallets, w2 <- wallets ]

  precondition :: ModelState HelloWorldModel -> Action HelloWorldModel -> Bool
  precondition state (Initialize w _) = isNothing $ getHelloWorldModelState' state w
  precondition state (Increment w _) = isJust $ getHelloWorldModelState' state w
  precondition state (Read w _) = isJust $ getHelloWorldModelState' state w

  startInstances :: ModelState HelloWorldModel -> Action HelloWorldModel -> [StartContract HelloWorldModel]
  startInstances _ _ = []

  -- Maps Actions to effects on the HelloWorldModel
  nextState :: Action HelloWorldModel -> Spec HelloWorldModel ()
  -- one slot will pass, the state will be initialized with i, minAdaValue will be spent
  nextState (Initialize wallet i) = do
    wait 1
    (helloWorldModel . at wallet) $= Just i
    withdraw wallet $ toValue minAdaTxOut
  -- one slot will pass, the state will be incremented, minAdaValue will be spent by the using wallet
  nextState (Increment wallet1 wallet2) = do
    wait 1
    (helloWorldModel . ix wallet1) $~ (+ 1)
    withdraw wallet2 $ toValue minAdaTxOut
  -- one slot will pass, the state will be incremented, minAdaValue will be spent
  nextState (Read wallet1 wallet2) = do
    wait 1
    withdraw wallet2 $ toValue minAdaTxOut

  perform :: HandleFun HelloWorldModel -> (SymToken -> AssetClass) -> ModelState HelloWorldModel -> Action HelloWorldModel -> SpecificationEmulatorTrace ()
  perform h _ model (Initialize wallet i) = do
    let handle = h $ InitializeKey wallet i
    withWait model $ callEndpoint @"initialize" handle i
    Last maybeCurrencySymbol <- observableState handle
    maybe (throwError $ GenericError $ "starting token sale for wallet " <> show wallet <> " failed")
          (\cs -> forM_ wallets $ \wallet2 -> do
                callEndpoint @"initialize" (h $ IncrementKey wallet wallet2) cs
                callEndpoint @"initialize" (h $ ReadKey wallet wallet2) cs)
          maybeCurrencySymbol
  perform h _ model (Increment wallet1 wallet2) = withWait model $ callEndpoint @"increment" (h $ IncrementKey wallet1 wallet2) ()
  perform h _ model (Read wallet1 wallet2) = withWait model $ callEndpoint @"read" (h $ ReadKey wallet1 wallet2) ()

deriving instance Eq (ContractInstanceKey HelloWorldModel w s e p)
deriving instance Show (ContractInstanceKey HelloWorldModel w s e p)

withWait :: ModelState HelloWorldModel -> SpecificationEmulatorTrace () -> SpecificationEmulatorTrace ()
withWait m c = void $ c >> waitUntilSlot ((m ^. currentSlot) + 1)

genWallet :: Gen Wallet
genWallet = elements wallets

wallets :: [Wallet]
wallets = [w1, w2, w3]

getHelloWorldModelState' :: ModelState HelloWorldModel -> Wallet -> Maybe Integer
getHelloWorldModelState' state wallet = M.lookup wallet . _helloWorldModel $ state ^. contractState

getHelloWorldModelState :: Wallet -> Spec HelloWorldModel (Maybe Integer)
getHelloWorldModelState wallet = do
  state <- getModelState
  return $ getHelloWorldModelState' state wallet
  