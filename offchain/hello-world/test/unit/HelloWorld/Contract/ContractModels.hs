{-# LANGUAGE TemplateHaskell #-}

module HelloWorld.Contract.ContractModels (testTree) where

import Control.Lens hiding (elements)
import Control.Monad (guard, join)
import Data.Data
import Data.Functor
import Data.Map qualified as M
import Data.Monoid (Last (..))
import Data.String (fromString)
import Data.Text qualified as T
import Ledger (minAdaTxOut)
import Plutus.Contract hiding (currentSlot, logInfo, throwError)
import Plutus.Contract.Test hiding (not)
import Plutus.Contract.Test.ContractModel
import Plutus.Trace (callEndpoint, throwError)
import Plutus.Trace.Emulator (EmulatorRuntimeError (..), observableState, waitUntilSlot)
import Plutus.V1.Ledger.Ada (toValue)
import Plutus.V1.Ledger.Slot (Slot)
import Plutus.V1.Ledger.Value (AssetClass)

import Test.QuickCheck
import Test.Tasty
import Test.Tasty.QuickCheck

import HelloWorld.Contract (IncHelloWorldSchema, InitHelloWorldSchema, ReadHelloWorldSchema, ReleaseHelloWorldSchema, increment', initialize, read'', release')

data HelloWorldModel = HelloWorldModel
  { _helloWorldModel :: M.Map SymToken Integer
  }
  deriving (Eq, Data, Ord, Show)

makeLenses ''HelloWorldModel

instance ContractModel HelloWorldModel where
  -- Actions that will be generated by QuickCheck and can be performed on the hello world contract
  data Action HelloWorldModel
    = Initialize Wallet Integer
    | Increment Wallet SymToken
    | Read Wallet SymToken
    | Release Wallet SymToken
    deriving (Data, Eq, Show)

  data ContractInstanceKey HelloWorldModel w s e p where
    InitializeKey :: Wallet -> Integer -> ContractInstanceKey HelloWorldModel (Last AssetClass) InitHelloWorldSchema T.Text ()
    IncrementKey :: Wallet -> ContractInstanceKey HelloWorldModel () IncHelloWorldSchema T.Text ()
    ReadKey :: Wallet -> ContractInstanceKey HelloWorldModel (Last Integer) ReadHelloWorldSchema T.Text ()
    ReleaseKey :: Wallet -> ContractInstanceKey HelloWorldModel () ReleaseHelloWorldSchema T.Text ()

  instanceContract :: (SymToken -> AssetClass) -> ContractInstanceKey HelloWorldModel w s e p -> p -> Contract w s e ()
  instanceContract _ (InitializeKey _ _) () = initialize
  instanceContract _ (IncrementKey _) () = increment'
  instanceContract _ (ReadKey _) () = read''
  instanceContract _ (ReleaseKey _) () = release'

  instanceWallet :: ContractInstanceKey HelloWorldModel w s e p -> Wallet
  instanceWallet (InitializeKey w _) = w
  instanceWallet (IncrementKey w) = w
  instanceWallet (ReadKey w) = w
  instanceWallet (ReleaseKey w) = w

  instanceTag key = fromString $ "instance tag for: " <> show key

  arbitraryAction :: ModelState HelloWorldModel -> Gen (Action HelloWorldModel)
  arbitraryAction state =
    oneof $
      join
        [ pure $ Initialize <$> genWallet <*> pure 0
        , guard (tokensExist state) $> (Increment <$> genWallet <*> genKeys state)
        , guard (tokensExist state) $> (Read <$> genWallet <*> genKeys state)
        , guard (tokensExist state) $> (Release <$> genWallet <*> genKeys state)
        ]
    where
      genKeys s = elements . M.keys . _helloWorldModel $ s ^. contractState
      tokensExist s = not . M.null . _helloWorldModel $ s ^. contractState

  initialState :: HelloWorldModel
  initialState = HelloWorldModel M.empty

  initialInstances :: [StartContract HelloWorldModel]
  initialInstances = []

  precondition :: ModelState HelloWorldModel -> Action HelloWorldModel -> Bool
  precondition _ (Initialize _ _) = True
  precondition state (Increment _ t) = tokenExists state t
  precondition state (Read _ t) = tokenExists state t
  precondition state (Release _ t) = tokenExists state t

  startInstances :: ModelState HelloWorldModel -> Action HelloWorldModel -> [StartContract HelloWorldModel]
  startInstances _ act = case act of
    Initialize w _ -> [StartContract (InitializeKey w 0) ()]
    Increment wi _ -> [StartContract (IncrementKey wi) ()]
    Read wr _ -> [StartContract (ReadKey wr) ()]
    Release wrel _ -> [StartContract (ReleaseKey wrel) ()]

  -- Maps Actions to effects on the HelloWorldModel
  nextState :: Action HelloWorldModel -> Spec HelloWorldModel ()
  -- four slots will pass, the state will be initialized with i, minAdaValue will be spent, a token will be minted
  nextState (Initialize wallet i) = do
    t <- createToken "foo"
    (helloWorldModel . at t) $= Just i
    withdraw wallet $ toValue minAdaTxOut
    wait 4
  -- one slot will pass, the state will be incremented
  nextState (Increment _ t) = do
    (helloWorldModel . ix t) $~ (+ 1)
    wait 1
  -- one slot will pass
  nextState (Read _ _) = do
    wait 1
  -- one slot will pass, the locked funds will be spent
  nextState (Release wallet token) = do
    deposit wallet $ symAssetClassValue token 1
    deposit wallet $ toValue minAdaTxOut
    (helloWorldModel . at token) $= Nothing
    wait 1

  perform :: HandleFun HelloWorldModel -> (SymToken -> AssetClass) -> ModelState HelloWorldModel -> Action HelloWorldModel -> SpecificationEmulatorTrace ()
  perform h _ model (Initialize wallet i) = do
    let handle = h $ InitializeKey wallet i
    withWait 3 model $ callEndpoint @"initialize" handle i
    Last maybeAssetClass <- observableState handle
    maybe
      (throwError $ GenericError $ "starting token sale for wallet " <> show wallet <> " failed")
      (registerToken "foo")
      maybeAssetClass
  perform h f model (Increment wallet t) = withWait 1 model $ callEndpoint @"increment" (h $ IncrementKey wallet) $ f t
  perform h f model (Read wallet t) = withWait 1 model $ callEndpoint @"read" (h $ ReadKey wallet) $ f t
  perform h f model (Release wallet t) = withWait 1 model $ callEndpoint @"release" (h $ ReleaseKey wallet) $ f t

deriving instance Eq (ContractInstanceKey HelloWorldModel w s e p)
deriving instance Show (ContractInstanceKey HelloWorldModel w s e p)

withWait :: Slot -> ModelState HelloWorldModel -> SpecificationEmulatorTrace () -> SpecificationEmulatorTrace ()
withWait n m c = void $ c >> waitUntilSlot ((m ^. currentSlot) + n)

genWallet :: Gen Wallet
genWallet = elements wallets

wallets :: [Wallet]
wallets = [w1, w2, w3]

tokenExists :: ModelState HelloWorldModel -> SymToken -> Bool
tokenExists state token = M.member token . _helloWorldModel $ state ^. contractState

propHelloWorldIncremetsOne :: Actions HelloWorldModel -> Property
propHelloWorldIncremetsOne = propRunActions (const $ pure True)

propNoFundsLocked :: Property
propNoFundsLocked =
  checkNoLockedFundsProof defaultCheckOptions $
    defaultNLFP
      { nlfpMainStrategy = do
          ts <- viewContractState helloWorldModel
          mapM_ (\t -> action $ Release w1 t) $ M.keys ts
      , nlfpWalletStrategy = \w -> do
          ts <- viewContractState helloWorldModel
          mapM_ (\t -> action $ Release w t) $ M.keys ts
      }

testTree :: Int -> TestTree
testTree n =
  testGroup
    "HelloWorld Model"
    [ testProperty "No Funds Locked Check" $ withMaxSuccess n propNoFundsLocked
    , testProperty "No Errors Check" $ withMaxSuccess n propHelloWorldIncremetsOne
    ]
