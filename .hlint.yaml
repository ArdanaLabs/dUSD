# HLint configuration file
# https://github.com/ndmitchell/hlint
##########################

# This file contains a template configuration file, which is typically
# placed as .hlint.yaml in the root of your project


# Specify additional command line arguments
#
# - arguments: [--color, --cpp-simple, -XQuasiQuotes]


# Control which extensions/flags/modules/functions can be used
#
# - extensions:
#   - default: false # all extension are banned by default
#   - name: [PatternGuards, ViewPatterns] # only these listed extensions can be used
#   - {name: CPP, within: CrossPlatform} # CPP can only be used in a given module
#
# - flags:
#   - {name: -w, within: []} # -w is allowed nowhere
#
# - modules:
#   - {name: [Data.Set, Data.HashSet], as: Set} # if you import Data.Set qualified, it must be as 'Set'
#   - {name: Control.Arrow, within: []} # Certain modules are banned entirely
#
# - functions:
#   - {name: unsafePerformIO, within: []} # unsafePerformIO can only appear in no modules
#
# Dangerous functions list taken from
# https://github.com/NorfairKing/haskell-dangerous-functions/blob/master/hlint.yaml

- functions:

  - {name: unsafeDupablePerformIO, within: []} # Unsafe
  - {name: unsafeInterleaveIO, within: []} # Unsafe
  - {name: unsafeFixIO, within: []} # Unsafe
  - {name: unsafePerformIO, within: []} # Unsafe

  # _VERY_ hard to get right, use the async library instead.
  # See also https://github.com/informatikr/hedis/issues/165
  - {name: forkIO, within: [], message: "Use functions from the async library instead."}
  # Mostly impossible to get right, rethink what you're doing entirely.
  # See also https://www.reddit.com/r/haskell/comments/jsap9r/how_dangerous_is_forkprocess/
  - {name: forkProcess, within: [], message: "Avoid altogether. Rethink what you're doing."}

  # Purposely fails. Deal with errors appropriately instead.
  - {name: undefined, within: [], message: "Don't use to signal errors. If using as a phantom value, use Proxy or Type Applications instead."}
  - {name: throw, within: [], message: "Don't throw from pure code. Use throwIO instead."} # Don't throw from pure code, use throwIO instead.
  - {name: Prelude.error, within: []}

  - {name: Data.List.head, within: []} # Partial, use `listToMaybe` instead.
  - {name: Data.List.tail, within: []} # Partial
  - {name: Data.List.init, within: []} # Partial
  - {name: Data.List.last, within: []} # Partial
  - {name: 'Data.List.!!', within: []} # Partial
  - {name: Data.List.genericIndex, within: []} # Partial
  - {name: Data.List.genericLength, within: []} # Use `fromIntegeral . length` instead

  # Same, but for Data.Text
  - {name: Data.Text.head, within: []}
  - {name: Data.Text.tail, within: []}
  - {name: Data.Text.init, within: []}
  - {name: Data.Text.last, within: []}

  - {name: minimum, within: [], message: "Partial when used on structures that can be empty."} # Partial
  - {name: minimumBy, within: [], message: "Partial when used on structures that can be empty."} # Partial
  - {name: maximum, within: [], message: "Partial when used on structures that can be empty."} # Partial
  - {name: maximumBy, within: [], message: "Partial when used on structures that can be empty."} # Partial

  # Same, but for Data.Text
  - {name: Data.Text.maximum, within: []}
  - {name: Data.Text.minimum, within: []}

  - {name: GHC.Enum.pred, within: []} # Partial
  - {name: GHC.Enum.succ, within: []} # Partial
  - {name: GHC.Enum.toEnum, within: []} # Partial
  - {name: GHC.Enum.fromEnum, within: []} # Does not do what you think it does.
  - {name: GHC.Enum.enumFrom, within: []} # Does not do what you think it does, depending on the type.
  - {name: GHC.Enum.enumFromThen, within: []} # Does not do what you think it does, depending on the type.
  - {name: GHC.Enum.enumFromTo, within: []} # Does not do what you think it does, depending on the type.
  - {name: GHC.Enum.enumFromThenTo, within: []} # Does not do what you think it does, depending on the type.

  - {name: unless, within: [], message: "Very confusing; use 'when (not cond)' instead."} # Really confusing; use 'when' instead.
  - {name: either, within: []} # Really confusing, just use a case-match.

  - {name: nub, within: []} # O(n^2)

  - {name: Data.Foldable.foldl, within: [], message: "Lazy accumulator; use foldl' instead."} # Lazy accumulator. Use foldl' instead.
  - {name: Data.Foldable.foldMap, within: [], message: "Lazy accumulator; use foldMap' instead."} # Lazy accumulator. Use foldMap' instead.
  - {name: Data.Foldable.sum, within: []} # Lazy accumulator
  - {name: Data.Foldable.product, within: []} # Lazy accumulator

  # Functions involving division
  - {name: Prelude.quot, within: []} # Partial, see https://github.com/NorfairKing/haskell-WAT#num-int
  - {name: Prelude.div, within: []}
  - {name: Prelude.rem, within: []}
  - {name: Prelude.mod, within: []}
  - {name: Prelude.quotRem, within: []}
  - {name: Prelude.divMod, within: []}

  # Does unexpected things, see
  # https://github.com/NorfairKing/haskell-WAT#real-double
  - {name: realToFrac, within: []}

  # Constructs rationals, which is either wrong or a bad idea.
  # - {name: 'Data.Ratio.%', within: []}

  # Don't use string for command-line output.
  - {name: System.IO.putChar, within: [], message: "Use functions in `Data.Text.IO` instead."}
  - {name: System.IO.putStr, within: [], message: "Use `Data.Text.IO.putStr` instead"}
  - {name: System.IO.putStrLn, within: [], message: "Use `Data.Text.IO.putStrLn` instead"}
  - {name: System.IO.print, within: [], message: "Use functions in `Data.Text.IO` together with `Data.Text.pack` and `show` instead."}

  # Don't use string for command-line input either.
  - {name: System.IO.getChar, within: [], message: }
  - {name: System.IO.getLine, within: [], message: "Use `Data.Text.IO.getLine` instead."}
  - {name: System.IO.getContents, within: [], message: "Does lazy IO."} # Does lazy IO.
  - {name: System.IO.interact, within: [], message: "Does lazy IO."}
  - {name: System.IO.readIO, within: []}
  - {name: System.IO.readLn, within: []}

  # Don't use strings to interact with files
  - {name: System.IO.readFile, within: [], "Don't use Strings to interact with files. Use
      functions in `Data.Text.Encoding` together with `Data.ByteString.readFile` instead."}
  - {name: System.IO.writeFile, within: [], "Don't use Strings to interact with files. Use
      functions in `Data.Text.Encoding` together with `Data.ByteString.writeFile` instead."}
  - {name: System.IO.appendFile, within: [], "Don't use Strings to interact with files. Use
      functions in `Data.Text.Encoding` together with `Data.ByteString.appendFile` instead."}

  # Can succeed in dev, but fail in prod, because of encoding guessing
  # It's also Lazy IO.
  # See https://www.snoyman.com/blog/2016/12/beware-of-readfile/ for more info.
  - {name: Data.Text.IO.readFile, within: [], message: "Guesses encoding; use `Data.ByteString.readFile`
      together with `Data.Text.Encoding.decodeUtf8'` instead."}
  - {name: Data.Text.IO.Lazy.readFile, within: [], message: "Guesses encoding and uses Lazy IO;
      if you still want Lazy IO, use `Data.ByteString.Lazy.readFile` together with 
      `Data.Text.Lazy.Encoding.decodeUtf8'` instead."}

  - {name: Data.Text.Encoding.decodeUtf8, within: [] # Throws on invalid UTF8
    , message: "Throws errors; use `Data.Text.Encoding.decodeUtf8'` or `Data.Text.Encoding.decodeUtf8With` instead."} 
  - {name: Data.Text.Lazy.Encoding.decodeUtf8, within: []
    , message: "Throws errors; use `Data.Text.Lazy.Encoding.decodeUtf8'` or `Data.Text.Lazy.Encoding.decodeUtf8With` instead."}
  # Could also add for decodeUtf16BE etc..., but those are less commonly used.

  - {name: fromJust, within: [], message: 'Partial'} # Partial

  # Does silent truncation:
  # > fromIntegral (300 :: Word) :: Word8
  # 44
  # If converting to an Integer, consider
  # using `toInteger` instead.
  - {name: fromIntegral, within: []
    , message: 'If converting to Integer, use toInteger instead. Otherwise, use `Data.Bits.toIntegralSized`.'}


  - {name: 'read', within: [], message: "Partial; use `Text.Read.readMaybe` instead."} # Partial, use `Text.Read.readMaybe` instead.
  
  # Deprecated, use `pure` instead.
  # See https://gitlab.haskell.org/ghc/ghc/-/wikis/proposal/monad-of-no-return
  # - {name: 'return', within: []}

# - modules:
  # Always import qualified post
  # - {name: '**', qualifiedStyle: post}
  # - { name: Control.Lens, within: [] }

- extensions:
  - { name: DeriveAnyClass, within: [] } # Dangerous

  - { name: DuplicateRecordFields, within: [] }

  - { name: NamedFieldPuns, within: [] }
#   - { name: TupleSections, within: [] }
  - { name: OverloadedLabels, within: [] }


# Add custom hints for this project
#
# Will suggest replacing "wibbleMany [myvar]" with "wibbleOne myvar"
# - error: {lhs: "wibbleMany [x]", rhs: wibbleOne x}

# The hints are named by the string they display in warning messages.
# For example, if you see a warning starting like
#
# Main.hs:116:51: Warning: Redundant ==
#
# You can refer to that hint with `{name: Redundant ==}` (see below).

# Turn on hints that are off by default
#
# Ban "module X(module X) where", to require a real export list
# - warn: {name: Use explicit module export list}
#
# Replace a $ b $ c with a . b $ c
# - group: {name: dollar, enabled: true}
#
# Generalise map to fmap, ++ to <>
# - group: {name: generalise, enabled: true}


# Ignore some builtin hints
# unless is confusing and doesn't reflect usual
# usage in English; "I'll go unless X." is more
# common than "Unless X, I'll go."
- ignore: { name: "Use unless" } 
# - ignore: {name: Use let}
# - ignore: {name: Use const, within: SpecialModule} # Only within certain modules


# Define some custom infix operators
# - fixity: infixr 3 ~^#^~


# To generate a suitable file for HLint do:
# $ hlint --default > .hlint.yaml
