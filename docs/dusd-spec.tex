\documentclass{article} % Use the custom invoice class (invoice.cls)
\usepackage[hidelinks]{hyperref}
\usepackage{todonotes}
\setuptodonotes{inline}
\setlength{\parindent}{0em}
\setlength{\parskip}{1pt}

\title{dUSD specification}
\begin{document}

\maketitle

\tableofcontents
\newpage

\section{Introduction}

\textbf{The purpose of this document is to let the dUSD team decide whether we are ready to deploy.}
It is a living document that serves as a forcing function for discussions
around, and agreement on, decisions. \\

The document starts with the ``Interactions'' section, a user-centric
perspective on what service we would like to offer.
Next come descriptions of requirements we have on those interactions in the
``Acceptance criteria'' section.
Any important implementation details that will be relevant for building such a
system are detailed in the section after that.
Finally, the ``Tests'' section provide a non-exhaustive list of the way we plan
to falsify whether we should deploy. \\

Note: Every subsection that contain `TBD' (``to be determined'') in the title is
not fully agreed upon yet.
Every subsection containing `TBC' (``to be confirmed'', by Ryan) in the title is
mostly agreed upon, but still requires last confirmation.
The other sections are considered law.

\section{Interactions}

\subsection{Discover market prices}

For the MVP version, we implement a simple, centralized market price discovery
mechanism. This mechanism involves only one on-chain component, called the Price
Module (PM), containing $48$ hours of price data, aggregated off-chain and put
on-chain by admin.

\subsubsection*{Price module: Write}

Admin can update the price information in the PM's datum at most once an hour by
adding one more price point.
When doing so, any price points older than $48$ hours are removed.

\subsubsection*{Price module: Read}

Anyone can use the price module as a read-only input UTXO to their transactions
in order to discover the last $48$ hours of price information, one price point
per hour.

% The V2 version is left here in comments, for now.
% \subsection{Discover market prices (V2)}
% 
% A price oracle is a timeline of UTXOs\footnote{
%   In the blockchain industry, people often talk about concepts like price
%   oracles and DEX pools. However, within the EUTXO system built by Cardano, the
%   fundamental concept we are dealing is the UTXO. This means that we are dealing
%   with a `state' of a price oracle as the fundamental concept, not the price
%   oracle itself. Now, Plutus scripts like price oracles, between being created
%   and destroyed, basically only allow to be updated and read. This means that
%   one can draw a `timeline' through a series of UTXO, each one disappearing into
%   a transaction that produces the next. This set of UTXOs is what is referred to
%   as ``the price oracle''.
% }
% which stores the price information of a given asset (e.g. ADA) in terms of a
% reference currency (USD).
% Each price oracle will store $48$ hours worth of price data, and be updatable
% once every few minutes.
% A number of price oracles will be created for each asset of interest.  The
% person creating each price oracle will connect it to a price feed coming from
% some CEX/DEX.
% Next, an Oracle Security Module (OSM) will be implemented.
% This is another ``timeline of UTXOs'', which allows admin to select a number of
% price oracles as trusted price feeds and combines their prices in a secure way.
% The resulting price is exposed to the blockchain ecosystem.
% 
% Note: In this document, off-chain entities containing information about the
% price will be referred to as price feeds (not price oracles), e.g. the Coinbase
% website.
% 
% Note: We will build price oracles both for ADA and dUSD.
% 
% \subsubsection*{Price oracle: Read}
% 
% The OSM can read all the pricing data stored in the price oracle.
% 
% \subsubsection*{Write}
% 
% The owner/creator of the price oracle can write a new price value to the oracle.
% This endpoint can be called once per hour.
% 
% \subsection{Oracle security module}
% 
% \subsubsection*{Read the `current' price}
% 
% Anyone can use the OSM as a read-only input UTXO to discover the price
% information of the last $48$ hours of some currency (e.g. ADA or dUSD relative
% to USD).
% 
% \subsubsection*{Update}
% 
% The OSM is updated once per hour.
% Anyone can do this by connecting the OSM to all accepted price oracles.
% 
% \subsubsection*{Update list of accepted price oracles}
% 
% Admin/governance can update the list of price oracles accepted by the OSM.
% 
\subsection{Vault}

\subsubsection*{List my vaults}

Users can list the (valid) vaults they own through the VaultUI, including their
information: Amount of collatoral, amount of debt (updated to this moment).

\subsubsection*{List all vaults}

The dUSD-API includes a function to list all existing (valid) vaults.

\subsubsection*{Get vault info}

The dUSD-API includes a function to gather information on a given vault.

\subsubsection*{Initialize vault}

Users can open a new vault.

\subsubsection*{Deposit}

Users can deposit ADA into their vaults.

\subsubsection*{Withdrawal}

Users can withdraw ADA from their vaults, as long as the resulting
collateralization ratio is above the liquidation ratio. The UX prevents users
from dropping their collateralization ratio below the so-called ``minimum
collateralization ratio''. The reason for this is that many people use the
MakerDAO system as experimentation and lose thousands of dollars on day one.
Power users can circumvent this by connecting to our dUSD-API directly. \\

Note: The liquidation ratio is hard-coded in the script and can only be changed
when the protocol is updated.

\subsubsection*{Take out loan}

Users can take out a loan in dUSD from one of their vaults if doing so doesn't
bring the collateralization ratio below the liquidation ratio\footnote{
  See note above, in `Withdrawal', on the minimum collateralization ratio in the
  UX.}.
There is a minimum for the total debt in one vault, called the ``debt
floor''\footnote{
  This is an on-chain mechanism, which means it is enforced on everyone.
}, as well as a ``debt ceiling''.

\subsubsection*{Pay back loan}

Users can pay back (part of) the loan in their vaults.

\subsubsection*{Collect stability fees}

Stability fees are stored in the vault and must be collected as protocol
profits. In the MVP, this will be done through a vault endpoint that allows the
admin user to collect all the fees. \\

% Post-MVP note: Once there is a concept of a buffer, any protocol update that
% changes the buffer should require the funds from the old buffer to be sent to
% the new buffer.

\subsubsection*{Liquidate vault}

A vault is considered in an unhealthy state if its collateralization ratio is
below the liquidation ratio, both according to the current price and the price
from one hour ago\footnote{
  The reason for this last part (using two prices) is that the vault owner
  should get an hour after a new price gets published to fix his vault before
  allowing liquidators to jump into action. In addition, if a vault becomes sick
  through a very temporary ADA crash, but recovers within an hour, there is no
  reason to liquidate.}.
Whenever a vault is in an unhealthy state, anyone can buy collateral (ADA)
through a Dutch auction.

\subsubsection*{Protocol update vault}

When a vault follows an outdated version of our protocol, a button appears in
the UX to update it to a newer version. \\

Note: This button only needs to be built into the UX (and the off-chain code
into dUSD-API) in dUSD's V2.

% Post-MVP, collecting stability fees will no longer be an admin-only action.
% Instead, the protocol will allow anyone to send the stability fees to a
% dedicated UTXO called the Buffer.
% 
% \subsection{Buffer}
% 
% The buffer is a UTXO responsible for holding the protocol's profits. In
% addition, the buffer allows the following actions:
% \begin{itemize}
%   \item Auctions between dUSD (from stability fees) and ADA (to store the
%     protocol profits).
%   \item Post-MVP, a divident payment mechanism will be set up to share the
%     protocol profits (ADA) with DANA holders.
% \end{itemize}
% 
% In the MVP, auctions between dUSD and ADA will be triggered by admin, who will
% also determine the size of the auctions. This can be used to bring dUSD closer
% to peg in the short term. Meanwhile, the stability fee can be adjusted to keep
% the buffer from running out of either dUSD or ADA, hence keeping the peg in the
% long term. \\
% 
% Auctions are based on selling tokens at a discount, just like in the auction
% module. The price at which the buffer auctions ADA/dUSD is based on the exchange
% rate between ADA and USD (see ADA price module). Note that selling dUSD in
% exchange for ADA happens when dUSD trades above peg, and hence selling it at the
% market rate for USD/ADA creates a discount. Similarly, selling ADA in exchange
% for dUSD happens when dUSD trades below peg, which means that selling it at the
% market rate for ADA/USD creates a discount.
% 
% \subsubsection*{Trigger auction of dUSD for ADA}
% 
% Admin can trigger a dUSD $\leftrightarrow$ ADA auction of any size smaller than
% the amount of dUSD held in the buffer.
% 
% \subsubsection*{Trigger auction of ADA for dUSD}
% 
% Admin can trigger an ADA $\leftrightarrow$ dUSD auction of any size smaller than
% the amount of ADA held in the buffer.

\subsection{Protocol Parameters Module}

The Protocol Parameters Module is a UTXO responsible for storing the
protocol-wide parameters which can be updated without requiring a protocol
update.

\subsubsection*{Set liquidation discount rate}

The admin user can set the liquidation discount, through a command line
interface available on the Ardana tenant referred to as the `admin CLI`.

\subsubsection*{Set stability fee}

The admin user can set the stability fee (in percentage per year), through the
admin CLI.

\subsubsection*{Set debt floor}

The admin user can set the debt floor (in dUSD) through the admin CLI.

\subsubsection*{Set debt ceiling}

The admin user can set the debt ceiling (in dUSD) through the admin CLI.

\subsection{Config UTXO}

\subsubsection*{Initialize protocol}

The procedure to initialize the protocol is the same as in the Hello Cardano
Template:
\begin{enumerate}
  \item Create an NFT through the generic NFT minting policy (see Hello Cardano
    Template)
  \item Using this NFT as the protocol's master NFT (identifying its Config
    UTXO), generate the script hashes of all the on-chain components' scripts
  \item Create the NFTs identifying the protocol parameters module and the price
    module
  \item Launch a protocol-wide parameters module and a price module
  \item Create a Config UTXO with the master NFT and a datum listing the script
    hashes and (parameters module and price module) NFTs
\end{enumerate}

\subsubsection*{Update protocol}

Initially, protocol updates are performed by admin. Eventually, governance
voting will take over. This is done through the Admin CLI. The process looks as
follows:
\begin{enumerate}
  \item If you want to update the price module, create a new price module and
    send the NFT identifying the old one to the new one
  \item Generate an NFT identifying the new parameters module and create the new
    module with that NFT
  \item Set the debt ceiling in the old parameters module to $0$
  \item Add the new vault script hash and NFTs (price module and parameters
    module) to the protocol's Config UTXO
\end{enumerate}

\section{Acceptance criteria}

\subsection{Price module}

Off-chain and on-chain criteria:
\begin{itemize}
  \item Writing the price value succeeds if and only if it is done by admin and
    at least an hour after the last update
  \item Reading the price data after writing a new price point successfully,
    shows no price information older than $48$ hours
  \item Reading the price data after writing a new price point successfully,
    shows the new price information
\end{itemize}

Price feed bot:
\begin{itemize}
  \item Always collects information from at least three sources successfully
  \item Running the cron service makes the UTXO get updated by at least three
    sources within $5$ minutes from the hour passing. What we mean by this, is
    that the price module can only be updated at least one hour after its last
    update, and should hence be updated soon after that limit.
\end{itemize}

% The version 2 price discovery mechanism is stored in these comments:
% \subsection{Price oracle}
% 
% \begin{itemize}
%   \item Only the owner can write to the oracle
%   \item Anyone can read the price data
%   \item Writing a price values removes outdated price values (older than 48
%     hours) from the datum.
% \end{itemize}
% 
% \subsection{Oracle security module}
% 
% \begin{itemize}
%   \item Admin (and only admin) can update the list of accepted price oracles
%   \item The OSM's price information cannot be updated without linking to all
%     accepted price oracles
%   \item The price oracles are read-only inputs to the ``update OSM'' endpoint
%   \item Reading the current price after updating the OSM's price information and
%     waiting for the given time delay, leads to the predicted `current' price.
%     This is the median over all price oracles of the price averaged over the
%     values in the last hour. (This smearing prevents flash drops on some
%     exchanges from making the OSM's result crash and many vaults liquidate.)
% \end{itemize}
% 
\subsection{Vault}

Each user has access to "www.vault.ardana.com". On this website, they can
connect their wallet and subsequently set up vaults and interact with their
existing vaults.

\begin{itemize}
  \item Anyone can create a vault, through a button on the website
  \item Anyone can create multiple vaults
  \item One person's vault being sick doesn't affect another vault owned by the
    same person, i.e. they can still take out loans and take out collateral
  \item The user can see how many vaults they own, and for each vault the amount
    of collateral, debt, collateralization ratio, and (post-MVP) how healthy the
    vault is
  \item Vault information is traced correctly (as read by the ``Gather vault
    info'' function in dUSD-API) when performing transactions (withdraw and
    deposit collateral, take out and pay back debt, and liquidating vaults
    (partially and fully))
  \item The vault overview is correct, clear and aesthetic
  \item Users can deposit and withdraw collateral, take out and pay back loans
    through forms on the website only if the collateralization ratio doesn't
    drop below the liquidation ratio through the dUSD-API
  \item Users can deposit and withdraw collateral, take out and pay back loans
    through forms on the website only if the collateralization ratio doesn't
    drop below the minimum collateralization ratio through the VaultUI
  \item No transaction can update the timestamp in the vault in a way that's
    inaccurate by more than $12$ hours
  \item Users cannot take out a loan or pay one back that leaves the dUSD debt
    above $0$ but below the debt floor\footnote{
    The purpose of the debt floor is to ensure good debt is issued against a
    vault to incentivize a liquidator to liquidate it should it become
    under-collateralized.}
% Comment for Version 2:
%   \item Users cannot take out a loan that leaves the dUSD debt above the debt
%     ceiling\footnote{
%     The debt ceiling has two purposes:
%     \begin{enumerate}
%       \item Deprecating collateral types by lowering the debt ceiling to below
%         the current amount of issued debt
%       \item Stopping OSM timing attacks, where vault owners exploit the OSM time
%         delay during a price crash, issuing a massive amount of debt thus
%         cashing out on worthless collateral
%     \end{enumerate}}
% 
% Debt ceilings are not useful against OSM timing attacks, since users can
% simply create multiple vaults.
  \item When going through a sequence of transactions, stability fees and dUSD
    debt are calculated correctly. `Correctly' here is defined in the
    Implementation details.
  \item Only the owner of the vault can create transactions other than
    liquidation
  \item Anyone can liquidate a sick vault
  \item Liquidation is possibly if and only if the vault is in an unhealthy
    state
  \item When a vault turns sick, the liquidation bot notices within $5$ minutes
  \item The price at which a vault is liquidated, is correct in accordance with
    Dutch auctions. This is defined in the implementation details.
  \item When the protocol is currently on a more recent version than a given
    vault, the UX shows a button to update the protocol one version
\end{itemize}

\todo{Add criteria for the Dutch auctions.}

\subsubsection*{Protocol update vault}

When a vault follows an outdated version of our protocol, a button appears in
the UX to update it to a newer version.

\subsection{Protocol Parameters Module}

\begin{itemize}
  \item Admin and only admin can set the protocol-wide parameters (stability
    fee, liquidation discount, debt floor and debt ceiling)
  \item The parameters can only be set within reasonable bounds. \todo{@Brian:
    What are these bounds, exactly?}
  \item If the protocol-wide parameters are changed, this change is immediately
    and correctly seen in liquidations and when taking out loans
\end{itemize}  

\subsection{Config UTXO}

\begin{itemize}
  \item The Config UTXO can be created with the proper contents (see
    `Implementation details')
  \item The protocol can be updated if and only if
    \begin{itemize}
      \item The new Config UTXO is exactly the same as the old one (in value and
        datum) except that the list of protocols has an extra element (added to
        the beginning of the list), and that element is a valid protocol (see
        `Implementation details') AND
      \item The transaction is signed by the admin user
    \end{itemize}
\end{itemize}

\section{Implementation details}

This section discusses what we need in order to implement the interactions
mentioned above.

\subsection{Price module}

The price module is a UTXO which can only be created by admin.
It contains in its datum a map from timestamps (POSIX time) to the price value.
An off-chain bot will be written which aggregates price information from at
least five sources (CEXes and DEXes) and applies the appropriate calculations on
this information in order to conclude what the most accurate current price is.
This current price will then be submitted as a transaction to the price module
using one of the admin keys. \\

Off-chain bot:
\begin{itemize}
  \item The bot is a cron job which runs a Purescript executable, which uses the
    dUSD-API. This is similar to the Admin CLI.
  \item The bot runs once every minute until successful, then waits for an hour,
    and repeats
\end{itemize}

Price module:
\begin{itemize}
  \item The on-chain code will be written in Plutarch
  \item The off-chain code will be built as an API in CTL, used both by an Admin
    CLI and a browser app
  \item The datum will contain a map from timestamps (in POSIX time) to price
    values
  \item The script address will be dependent on three admin public
    keys\footnote{
      These admin keys can only be updated when the protocol is updated.
      This decision will be enforced by using the keys to determine the script
      address, rather than putting them into the datum.
    }
\end{itemize}

Note: The off-chain bot will combine the price feeds through two operations:
\begin{enumerate}
  \item For each price feed, average the price over the values from the last
    hour
  \item Take the median of the resulting values
\end{enumerate}

\subsubsection*{Protocol updates}

Protocol updates work a bit differently for the price module than for the other
on-chain components.
The reason for this is that maintaining a price module costs a significant
amount in gas fees, so we only want to maintain one version.
This means that the price module will not be part of the regular protocol
updates, but instead the configuration module will refer to one NFT as
identifying the price module.
Admin is then allowed to update the price module by moving its NFT to a new
UTXO, which is associated with the new price module script.
Lastly, it is important to note the drawback of this update mechanism, namely
that the price module must forever remain backwards compatible.
This is because an arbitrary number of old protocols will still depend on the
most up-to-date price module, and these old protocols must still be viable.

% \subsection{Price oracle}
% 
% Each price oracle will carry an NFT used as a unique identifier.
% In addition, each price oracle contains the public key associated with the
% wallet which created it, so that only the creator of the oracle can update it.
% The price oracle can be updated once every hour.
% We will start with $3-5$ price oracles. \\
% 
% The OSM can be updated once every hour, and this transaction can be created by
% anyone.
% When it does, it pulls in the price information from all accepted price oracles
% and applies two calculations to that feed.
% First, it only retains the $70\%$ of price oracles that have most recently been
% updated, to assure obtaining the most recent price available.
% Secondly, it takes the median of the resulting price values.
% 
% \todo{How will price oracle updates and the OSM updates be rewarded? With a
% slight fee every time, coming from the profits stored in the buffer? Or should
% using a price oracle or OSM cost money, also to dUSD protocol users?}
% 
% If the OSM has not been updated for at least two hours, it stops spreading price
% information, thereby shutting down vault liquidations as well as creating new
% loans until the OSM is updated.
% This is a measure which will only kick in in the case of very serious resource
% contention, in which case once the system starts up again, we want to ensure
% that updating the OSM is the first transaction that happens.
% 
% \todo{Should the price oracles and the OSM all be combined into one UTXO, or
% be split into separate UTXOs?}
% 
\subsection{Vault}

How stability fees work:
\todo{Explain what stability fees are.}
\todo{Explain how stability fees are stored: In the vault's value, and in its
datum. Note the requirements this puts on the vault's validator script.}
\todo{Explain time-dependent stability fees. \\
Note: Stability fees are calculate in \#days, rounded up, to avoid people
abusing the $12$h window. \\
Stability fees can change, but we have a history of them, so we can reconstruct
the past to calculate the total debt due.}

How Dutch auctions work: \todo{Explain.}

\todo{Explain the VaultID system, and VaultID minting policy.}

\begin{itemize}
  \item On-chain code: Plutarch
  \item Off-chain code: PAB, tested through Maeserat and ContractModel tests.
    This means that users will use the frontend to contact our remote wallet
    PAB\footnote{
      The following statement is still being verified by Dan Firth's research.
      The protocol implementation as outlined in this document requires us to
      run two separate PABs.
      One PAB, referred to as the ``admin PAB'', will be connected to a wallet
      running locally on the Ardana Tenant.
      This admin PAB will be used to sign and submit admin transactions.
      On the other hand, the ``remote PAB'' will use Cardano's remote wallet
      implementation in order to generate the unsigned tranasctions our users
      need and yield them.
      These unsigned transactions will be sent to the user, where locally
      running javascript will connect to their wallet in order to sign and
      submit the transactions.
    }, which will generate the unsigned transaction they need.
  \item Collecting information on one person's vaults as well as vaults in
    general, are implemented as off-chain endpoints within the PAB, to avoid
    having to build a separate backend for the dUSD system
  \item A vault is a UTXO which holds an NFT, as a unique ID, and the collateral
    assets
  \item The vault's address is dependent on the owner's public key, ensuring the
    key cannot be changed by any transactions
  \item The vault's address is dependent on the three admin keys, ensuring the
    vault is connected to the correct buffer and price modules
  \item The vault's datum consists of two pieces of information: A timestamp of
    its last update and the amount of dUSD debt (including stability fee)
    calculated at that time
  \item Liquidation is only allowed if both the current price and the price of
    an hour ago state that the current collateralization ratio is below the
    liquidation ratio.
    This is a measure taken to allow vault owners a chance to make their vaults
    healthy whenever the price of the collateral dropped.
  \item All transactions must have a ``txInfoValidRange'' that's less than $12$
    hours long, to provide sufficiently accurate temporal information. This is
    enforced on-chain. The timestamp extracted from any transaction is the the
    beginning of this interval.
  \item When a dUSD loan gets paid back, the dUSD coins get burned in the vault.
    This means that the stability fee is burned as well, which drives up the
    dUSD price and allows for surplus auctions (rewarding governance owners).
    Note that the burning of the stability fees isn't directly linked to an
    equal amount of dUSD being minted in the buffer.
    Instead they are linked indirectly, through the former driving up the dUSD
    price and hence triggering surplus auctions.
\end{itemize}

Notes:
\begin{itemize}
  \item We do not want to make it possible to combine multiple transactions into
    one, as MakerDAO does.
    This is too complex a feature for an MVP, and once Orbis launches, gas fees
    will be very low.
  \item The names of the NFTs carried in the buffer and price modules, will be
    used as arguments to the vault's Plutus script.
    This ensures the vaults connect with the correct protocol setup.
  \item The frontend code will set the minimum collateralization ratio, which
    will be adjustable by Ardana itself.
\end{itemize}

In addition to the vault itself, we need a liquidation bot in order to liquidate
sick vaults as quickly as possible.
This liquidation bot will be a Haskell script running once every $10$ minutes on
the Ardana Tenant, as a systemd service.
The script will connect to a separate contract instance (set up specifically for
this script) of the dUSD admin PAB to collect information on all dUSD vaults,
and determine which ones are sick\footnote{
  This will be done by querying the ChainIndex.
  \todo{Figure out how to do this efficiently.
    Can we specifically find the vaults by checking the ADA price module's
    history?
  }
}.
For each sick vault, the script will set up a transaction through the admin DEX.
This transaction connects the vault to a trusted DEX (initially: a Minswap DEX
trading dUSD for ADA), liquidating the vault to the extend necessary.
In brokering this transaction, the liquidation bot earns profits, which are
stored in the admin wallet and used for protocol development.

\todo{Describe how the Dutch auctions will work, including liquidation fees
(?).}

Note: If the price module hasn't been updated in the last $4$ hours,
transactions which require price information\footnote{
  These transactions are taking out loans, withdrawing collateral and
  liquidating vaults.
} are temporarily paused. This is verified by requiring the time span (in the
vault transaction) to maximally cover $15$ minutes. Note in addition that this
requirement means that any vault transaction must be added to the blockchain
within $15$ minutes, or it will be rejected and has to be recreated and
resigned.

\subsection{Config UTXO}

When initializing the Config UTXO, we should manually check if the Config UTXO
is valid. This means the following:
\begin{itemize}
  \item The Config UTXO contains an NFT
  \item The Config UTXO contains the necessary parameters directly in its datum:
    \begin{itemize}
      \item Price module NFT
      \item dUSD asset class
    \end{itemize}
  \item The Config UTXO contains in its datum a non-empty (!) list of protocols,
    where each protocol constitutes:
    \begin{enumerate}
      \item The protocol parameters module's ID
      \item The vault script
      \item Optionally: The buffer's ID
    \end{enumerate}
\end{itemize}

Note that none of this is enforced automatically, but rather checked manually
when launching the protocol.

\todo{Explain the Admin CLI implementation of ``update protocol''.}

\subsection{Buffer}

The buffer's script address will be dependent on the same three admin public
keys as the price module. \\

The main advantage of this price modules-based approach, is that we always sell
at a trusted price, without allowing as many opportunities for manipulations.
(Classic auctions are vulnerable for manipulations through resource contention,
DEXes through e.g. sandwich attacks.) \\

Note that the buffer itself cannot mint or burn dUSD. This can only be done
inside vaults.

\subsection{Protocol Parameters Module}

The protocol parameters module will contain in its datum a map from timestamps
to the stability fee set at that timestamp.
We use a map to make the stability fee calculations as accurate as
possible.\footnote{
  Imagine you open a vault, take out a loan and then leave the vault alone for
  two years.
  Just before you pay back the loan, governance decides to increase the
  stability fee.
  We want to use the stability fee that was applicable to the two year period
  when calculating your stability fee wherever possible, rather than
  retro-actively increasing your debt.
}. \\

We put together this map by figuring out the time of execution of the
transaction that changes the stability fee, within that transaction itself.
This is done by setting the timestamp to be the beginning of the
``txInfoValidRange'' range\footnote{
  \url{https://playground.plutus.iohkdev.io/doc/haddock/plutus-ledger-api/html/Plutus-V1-Ledger-Contexts.html}},
where the on-chain validator enforces this range to be less than $12$ hours
long. \\

In order to prevent datum overflow\footnote{
  This means we want to prevent the datum from becoming too big}
we limit the size of the map to $20$ data points.
This means that any transaction that changes the stability fee, will both add a
new entry to the map, and remove the oldest entry in case there are more than
$20$ entries. \\

The protocol parameters module will be a UTXO that includes in its datum the following:
\begin{itemize}
  \item Map from timestamps to stability fees
  \item Liquidation discount
  \item Liquidation ratio
  \item Debt floor
  \item Debt ceiling
  \item Auction discount
\end{itemize}

\subsection{dUSD minting policy}

The dUSD minting policy refers to the Configuration Module by its unique NFT.
The Configuration Module contains both the script address of the vaults in the
most recent version of the protocol, and the CurrencySymbol used to identify
vault's NFT IDs. The minting policy allows minting and burning dUSD if and only
if the most recent vault script passes on the transaction, there is exactly one
vault among the inputs of the transaction, and the vault is legitimate (i.e. it
contains an NFT as an ID with the correct CurrencySymbol).

\section{Tests}

\begin{itemize}
  \item Test for Cardano network congestion
  \item Test what happens if someone hacks one or more price oracles
  \item Other attack vectors which are not specific to our application, should
    be listed and tested for
\end{itemize}

\section{Remarks}

Some extra remarks:
\begin{itemize}
  \item The admin user will collect the stability fees in dUSD. This allows him
    to trade between dUSD and ADA to help dUSD stick to its peg, compensation
    for short-term fluctuations to some extent.
  \item The Admin CLI will run on a server called the Ardana Tenant, in a secure
    facility. This server will run its own CTL runtime dependencies.
  \item There will be one admin key, stored on three YubiHSMs: One in the Ardana
    Tenant, one in the secure facility where the Ardana Tenant is located, and
    one secured personally by a trusted member of the Ardana team. The key will
    be generated by a trusted member of the Ardana team and put on all three
    YubiHSMs.
  \item The website requires CTL runtime dependencies to be running. This will
    be done in the cloud, on Digital Ocean. As a backup, we will make sure the
    dUSD frontend can also work against MLabs' public CTL runtime dependencies.
  \item The admin key is hardcoded in the vault, price module and parameters
    module scripts, and can only be changed through protocol updates
  \item All parameters the protocol depends on, are either included in the
    Parameters Module or hardcoded into the scripts in order to prevent updating
    them outside of a protocol update
  \item Random reminder about Cardano lingo:
    \begin{itemize}
      \item Minting Policy: the validator script that controls how the tokens
        are minted
      \item Currency symbol: The hash of a minting policy that controls how
        tokens with this currency symbol are minted
      \item Token name: An arbitrary byte string used to distinguish tokens with
        the same currency symbol
      \item Asset Class: A pair of a Currency symbol and Token name useful to
    have a word for because it's all the information about a token
    \end{itemize}
\end{itemize}

One important question to discuss, is what happens in case a bug is found in the
dUSD protocol. Let us start by categorizing any protocol bug into two types:
\begin{enumerate}
  \item Someone can mint dUSD at a discount
  \item Someone can get others' collateral at a discount
\end{enumerate}

In the former case, we can fix the issue and launch a protocol update. Since old
protocol versions cannot mint dUSD, this resolves the problem.
If the problem is too complex to fix quickly, a temporary "no minting" protocol
update can be launched, and then update that one once we actually fixed it. \\

The latter case forms a bigger issue.
The only way out that we can see, is to give governance the option to freeze the
protocol.
However, upon unfreezing, the vault script would be unchanged.
Given that hackers are more technically capable than most users, they will be
able to steal much collateral at a discount despite the freeze.
One option would be that governance cannot only freeze the protocol, but also
launch a new vault script and force-update vaults to that script.
This in turn creates a new issue, namely that it opens up the possibility for a
protocol-wide rugpull.
At least for PR purposes, this seems much more dangerous than the option of
having people steal collateral at a discount, given the extensive testing Ardana
is engaging in.
Therefore, we decided to accept the risk of bugs over the risk of full
centralized `emergency' control.

\section{To be determined}

\begin{itemize}
  \item Liquidation ratio
  \item Liquidation discount
  \item Minimum collateralization ratio
  \item Debt floor
  \item Debt ceiling
\end{itemize}

\end{document}
