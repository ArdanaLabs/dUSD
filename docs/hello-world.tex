\documentclass{article}
\usepackage{hyperref}
\usepackage{todonotes}
\setuptodonotes{inline}
\setlength{\parindent}{0em}

\title{Hello World specification}
\begin{document}

\maketitle

\section{Interactions}

\begin{itemize}
  \item UTXO with a datum that is an int
  \item Website shows the int
  \item Website lets you increment the int
\end{itemize}

\section{Acceptance Criteria}

\begin{itemize}
  \item Anyone can increment the int (no authentication)
\end{itemize}

\section{Implementation Details}

\begin{itemize}
  \item This all happens in the dUSD repo
  \item On-chain code written in Plutarch
  \item Off-chain code written in PAB
  \item Plutarch code gets compiled into a ByteString, which can be included in
    the PAB transactions as it would for PlutusTx
  \item Front-end
  \begin{itemize}
    \item Foundations built in HTML/CSS, with one Purescript component to link
      with the PAB and browser wallets (TBD)
    \item User wallet: Nami (for first version)
  \end{itemize}
  \item Once we’re done, we can `git tag' the commit where that’s done and then
    upgrade this to the price module implementation in-place.
  \item How to balance transactions?
    \todo{
      \url{https://github.com/input-output-hk/plutus-apps/issues/249\#issuecomment-1085834665}
    }
\end{itemize}

\section{Tests}

\begin{itemize}
  \item Apropos-tx testing for the on-chain code
  \begin{itemize}
    \item the plutarch increment function satisfies the property (increment(n) = n + 1)
    \item the compiled validator validates if and only if the output datum returns to the script address, is of type integer, and is equal to increment(input datum)
  \end{itemize}
  \item Unit test for on-chain code:
  \begin{itemize}
    \item increment from 0 to 1
    \item increment from 1 to 2
  \end{itemize}
  \item E2E frontend testing: Set up NixOS VM, launch browser, connect to Nami
  \begin{itemize}
    \item Selenium
      \begin{itemize}
        \item Check that when the server is initialized, the website shows the
          number $0$
        \item Check that incrementing works: $0$ to $1$, $1$ to $2$
        \item Open two browsers, connected to two separate wallets, and check
          that incrementing on one updates the number on the other after
          refresh: $0$ to $1$, $1$ to $2$
        \item Launch the two browsers in separate VMs.
          \todo{See issue \url{https://github.com/ArdanaLabs/dUSD/issues/87}.}
      \end{itemize}
    \item Lighthouse score above $90$, to check website performance
  \end{itemize}
  \item PAB E2E testing: The same tests will be ran as for the frontend tests,
    but using a second PAB to sign and submit transactions.
    The tests will be ran against a local testnet set up through Maeserat.
  \item Contract Model Tests:
    Allow us to do QuickCheck-like property tests on contracts. This is achieved by:
    \begin{itemize}
      \item creating a model for the contract-state (ContractModel)
      \item defining actions that the contract supports and how they:
      \begin{itemize}
        \item are executed in the blockchain emulator 
        \item modify the modelled contract-state
      \end{itemize}
    \end{itemize}
    By defining how the actions modify the contract-state we implicitly specify the properties our contract has to hold,
    since the state of the model and the state of the emulated blockchain are compared against each other on every action execution.
    Having a basic property test which doesn't require for any additional predicates to hold, covers the property of being "correct" i.e. it's matching the
    expected model state specification.
    Besides of the implicit specification of properties we can additionally check for predicates at the end of a sequence of actions using:
    \begin{itemize}
      \item the contract-specific state
      \item the current slot
      \item the wallet balances
      \item the amount that has been minted
    \end{itemize}
    
  \begin{itemize}
    \item Actions
    \begin{itemize}
      \item Initialize
        \begin{itemize}
          \item always mints a token that is used to identify the scripts UTxO
          \item initializes the scripts UTxO datum with any given integer
        \end{itemize}
      \item Increment
        \begin{itemize}
          \item increments scripts UTxO datum by one
        \end{itemize}
      \item Read
        \begin{itemize}
          \item reads the scripts UTxO datum
        \end{itemize}
      \item Release
        \begin{itemize}
          \item releases the scripts UTxOs to the calling public key
        \end{itemize}
    \end{itemize}
    \item Predicates
      \begin{itemize}
        \item At the end of the scripts lifecycle no funds should be locked at the script address
      \end{itemize}
  \end {itemize}
  \item This project will be deployed to mainnet to run manual tests
\end{itemize}

\section{Features to be added}

\begin{itemize}
  \item Frontend integration with Yoroi, Daedelus. Any other browser wallets?
  \item Replace datum to something not-builtin, to test encoding/decoding match
    between on-chain and off-chain
  \item Maeserat: Volume tests, benchmarks for time and memory consumption
  \item Set up an NFT-system to persistently identify and track the Hello World
    UTXOs
\end{itemize}

\end{document}
